---
title: manacher算法
tags: 
    - leetcode
    - manacher
    - string
    - 回文字符串
    - 算法
    - 数据结构
date: 2018-12-31 01:24:40
---


# manacher 算法

Manacher算法是一个用来寻找字符串最长回文子串的算法，它能够在线性时间内解决这个问题。

<!--more-->

## 思路

从左到右遍历字符串，在遍历每个字符的时候，都看看以这个字符为中心，最大能够产生多长的回文子串。例如"121"和"22"，但是如果仅仅是这样的话，每一次的中心字符寻找最常回文子串都和前面的一个没有关系的话，那么时间复杂度为`O(n^2)`，不符合我们的要求。

所以说，manacher算法能够将两个相邻的字符为中心的子串的寻找到关系。

为了方便叙述`121`和`22`这样的奇偶数目不同的回文子串，这里将他扩展为`#1#2#1#`和`#2#2#`，这样就有轴心了，当然`#`可以是任何没有出现在原始字符串中的字符。

然后呢？还得有一些先验的辅助变量。

1. 数组pArr，pArr[i]用来记录从charArr[i]这个字符向左右扩展，最大的扩展半径，最小就是为1。  
2. 整数pR，用来记录每一个i位置的字符之前(包括这个字符)为中心点，最右侧的位置能到达的位置（**即将到达的位置**）。  
3. 整数index，表示最近一次更改pR时候的index  

## 两种情况(或者说4种情况)

![](https://i.loli.net/2018/12/30/5c28e74ca3012.png)

重复一遍

1. 如果i根本不在pR-1这个范围内，那么这个时候，只能一点点算pArr[i]  
2. 如果在这个范围内  
    - 如果以index为中心，i的对称点为中心的最长回文子串范围不超过了以index为中心的范围，则pArr[i] = pArr[i']  
    - 如果以index为中心，i的对称点为中心的最长回文子串范围超过了以index为中心的范围，则这个时候，pArr[i] = pR - i   
    - 如果正好左边界重合了， 需要判断右大之后的是不是也是以i为中心点的回文字符串的一部分，这部分就得手动了。  
    
## 代码实现

[this](https://github.com/menghuu/leetcode2/blob/master/src/String/m5_Longest_Palindromic_Substring.py)

## 参考/抄袭资料

《程序员代码面试指南：IT名企算法与数据结构题目最优解》， P484